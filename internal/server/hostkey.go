// File: internal/server/hostkey.go
// Project: Terminal Velocity
// Description: SSH server host key management with persistent storage
// Version: 2.1.0
// Author: Joshua Ferguson
// Created: 2025-01-07

// Package server implements SSH host key management for Terminal Velocity.
//
// Host Key Overview:
// SSH servers require a host key to prove their identity to clients. This prevents
// man-in-the-middle attacks where an attacker impersonates the server. The host key:
//   - Is an asymmetric key pair (private key on server, public key given to clients)
//   - Must be consistent across server restarts (clients cache the fingerprint)
//   - Should be kept secret (private key) and secure (file permissions 0600)
//   - Uses ED25519 algorithm (modern, fast, secure)
//
// Key Persistence:
// Unlike ephemeral keys that change on restart, this implementation persists the
// host key to disk. Benefits:
//   - Clients don't get "host key changed" warnings on server restart
//   - Consistent server identity across deployments
//   - Can backup/restore key with server configuration
//
// Security Considerations:
//   - Private key file MUST have 0600 permissions (owner read/write only)
//   - Private key should be excluded from version control (.gitignore)
//   - Backup private key securely (encrypted backup recommended)
//   - If private key is compromised, generate new one and inform users
//
// Key Generation:
// Uses Go's crypto/ed25519 package which provides:
//   - Cryptographically secure random number generation
//   - 256-bit security level
//   - Fast signature generation and verification
//   - Small key size (32 bytes private, 32 bytes public)
//
// File Format:
// Private key is saved in OpenSSH format (PEM-encoded), compatible with:
//   - OpenSSH ssh-keygen tool
//   - Standard SSH client expectations
//   - Easy key inspection and management
package server

import (
	"crypto/ed25519"
	"crypto/rand"
	"encoding/pem"
	"fmt"
	"os"
	"path/filepath"

	"golang.org/x/crypto/ssh"
)

// loadOrGenerateHostKey loads an existing SSH host key from file or generates a new one.
//
// This is the main entry point for host key management. It implements a "load or
// create" pattern that ensures the server always has a valid host key.
//
// Execution Flow:
//   1. Check if key file exists at keyPath
//   2. If exists: Load private key from file
//   3. If not exists: Generate new ED25519 key pair and save to file
//   4. Return ssh.Signer (interface for signing SSH messages)
//
// Parameters:
//   - keyPath: Filesystem path where key should be loaded from or saved to
//              Example: "data/ssh_host_key" or "/etc/terminal-velocity/host_key"
//
// Returns:
//   - ssh.Signer: Signing interface for SSH server configuration
//   - error: File I/O, permission, or cryptographic error
//
// File Permissions:
// Generated keys are saved with 0600 permissions (owner read/write only).
// This is critical for security - SSH clients may refuse to connect if the
// host key is world-readable.
//
// Directory Creation:
// If the parent directory doesn't exist, it will be created with 0755 permissions.
// Example: If keyPath is "data/keys/host_key", the "data/keys/" directory is created.
//
// First-Time Setup:
// On first run, when no key exists:
//   - Generates new ED25519 key pair (random, secure)
//   - Saves private key to keyPath with 0600 permissions
//   - Saves public key to keyPath.pub with 0644 permissions
//   - Logs the fingerprint for administrator verification
//
// Error Handling:
// Any error (file permissions, disk full, crypto failure) is fatal and prevents
// server startup. This ensures the server never runs with an insecure key.
func loadOrGenerateHostKey(keyPath string) (ssh.Signer, error) {
	// Try to load existing key
	if _, err := os.Stat(keyPath); err == nil {
		log.Info("Loading existing SSH host key from %s", keyPath)
		return loadHostKeyFromFile(keyPath)
	}

	// Key doesn't exist, generate a new one
	log.Info("Generating new SSH host key and saving to %s", keyPath)
	return generateAndSaveHostKey(keyPath)
}

// loadHostKeyFromFile loads an SSH private key from a file.
//
// This function reads a private key file in OpenSSH format and parses it into
// an ssh.Signer interface that can be used by the SSH server.
//
// Supported Key Formats:
//   - OpenSSH format (PEM-encoded, generated by this package)
//   - Traditional PEM format (RSA, ECDSA, ED25519)
//   - Passphrase-protected keys (not supported, will error)
//
// Parameters:
//   - keyPath: Path to private key file
//
// Returns:
//   - ssh.Signer: Signing interface for SSH server
//   - error: File not found, parse error, or unsupported format
//
// Security Note:
// This function does NOT verify file permissions. The caller should ensure the
// key file has appropriate permissions (0600). Future enhancement could add
// permission checking here.
//
// Key Type Detection:
// The ssh.ParsePrivateKey function automatically detects the key type from the
// file contents. No need to specify algorithm (RSA, ECDSA, ED25519).
func loadHostKeyFromFile(keyPath string) (ssh.Signer, error) {
	privateKeyBytes, err := os.ReadFile(keyPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read host key file: %w", err)
	}

	// Parse the private key
	signer, err := ssh.ParsePrivateKey(privateKeyBytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse host key: %w", err)
	}

	log.Info("SSH host key loaded successfully (type: %s)", signer.PublicKey().Type())
	return signer, nil
}

// generateAndSaveHostKey generates a new ED25519 host key and saves it to disk.
//
// This function is called when no existing host key is found. It:
//   1. Generates a new ED25519 key pair using crypto/rand
//   2. Creates directory structure if needed
//   3. Saves private key with 0600 permissions
//   4. Saves public key with 0644 permissions (for reference)
//   5. Logs fingerprint for admin verification
//
// ED25519 Algorithm:
// Modern SSH key algorithm with benefits:
//   - 256-bit security level (equivalent to RSA 3072-bit)
//   - Fast signature generation and verification
//   - Small key size (64 bytes total: 32 private + 32 public)
//   - Resistant to side-channel attacks
//   - No parameters to configure (unlike RSA key size)
//
// Parameters:
//   - keyPath: Path where private key will be saved
//              Public key saved to keyPath + ".pub"
//
// Returns:
//   - ssh.Signer: Signing interface for immediate use
//   - error: Crypto failure, directory creation, or file write error
//
// File Structure:
//   keyPath (private key):
//     -----BEGIN OPENSSH PRIVATE KEY-----
//     <base64-encoded key data>
//     -----END OPENSSH PRIVATE KEY-----
//
//   keyPath.pub (public key):
//     ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFoo... terminal-velocity
//
// Security:
//   - Uses crypto/rand for cryptographically secure random generation
//   - Private key saved with 0600 (owner read/write only)
//   - Public key saved with 0644 (world-readable, safe to share)
//
// Fingerprint Logging:
// The SHA256 fingerprint is logged on generation. This should be communicated
// to users so they can verify server identity on first connection.
func generateAndSaveHostKey(keyPath string) (ssh.Signer, error) {
	// Generate ED25519 key pair
	_, privateKey, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate key: %w", err)
	}

	// Create SSH signer from private key
	signer, err := ssh.NewSignerFromKey(privateKey)
	if err != nil {
		return nil, fmt.Errorf("failed to create signer: %w", err)
	}

	// Ensure the directory exists
	dir := filepath.Dir(keyPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create key directory: %w", err)
	}

	// Marshal the private key to OpenSSH format
	privateKeyBytes := marshalED25519PrivateKey(privateKey)

	// Write private key to file with restrictive permissions (0600)
	if err := os.WriteFile(keyPath, privateKeyBytes, 0600); err != nil {
		return nil, fmt.Errorf("failed to write host key: %w", err)
	}

	log.Info("New SSH host key generated and saved (type: ED25519, fingerprint: %s)",
		ssh.FingerprintSHA256(signer.PublicKey()))

	// Also save the public key for reference
	publicKeyPath := keyPath + ".pub"
	publicKeyBytes := ssh.MarshalAuthorizedKey(signer.PublicKey())
	if err := os.WriteFile(publicKeyPath, publicKeyBytes, 0644); err != nil {
		log.Warn("Failed to write public key file: %v", err)
		// Non-fatal, continue
	}

	// Log the public key fingerprint for verification
	log.Info("Public key fingerprint (SHA256): %s", ssh.FingerprintSHA256(signer.PublicKey()))
	log.Info("Public key saved to: %s", publicKeyPath)

	return signer, nil
}

// marshalED25519PrivateKey marshals an ED25519 private key to OpenSSH format.
//
// This function converts a raw ED25519 private key (64 bytes) into the OpenSSH
// private key file format that SSH clients expect. The format is:
//   - PEM-encoded (-----BEGIN/END----- markers)
//   - Base64-encoded binary data
//   - Compatible with ssh-keygen and standard SSH tools
//
// Parameters:
//   - privateKey: Raw ED25519 private key (64 bytes)
//
// Returns:
//   - []byte: PEM-encoded private key in OpenSSH format
//
// Format Details:
// The OpenSSH format includes:
//   - Key algorithm identifier (ssh-ed25519)
//   - Public key bytes
//   - Private key bytes
//   - Check bytes for integrity verification
//   - Optional comment field
//
// Fallback Behavior:
// If ssh.MarshalPrivateKey fails (shouldn't happen with ED25519), this function
// falls back to returning the raw private key bytes. This is not ideal but prevents
// server startup failure.
//
// Error Handling:
// Marshaling errors are logged as warnings, and the raw key is returned as fallback.
// This ensures server startup succeeds even if the format conversion fails.
func marshalED25519PrivateKey(privateKey ed25519.PrivateKey) []byte {
	// Use ssh.MarshalPrivateKey to generate the OpenSSH format
	pemBlock, err := ssh.MarshalPrivateKey(privateKey, "")
	if err != nil {
		// Fallback to raw key format if marshaling fails
		log.Warn("Failed to marshal private key to PEM format, using raw format: %v", err)
		return privateKey
	}

	// Encode the PEM block to bytes
	return pem.EncodeToMemory(pemBlock)
}

// generateHostKey generates a temporary ED25519 host key (DEPRECATED).
//
// ⚠️  WARNING: This function is deprecated and should NOT be used.
//
// Deprecation Reason:
// This function generates a temporary host key that is NOT persisted to disk.
// This causes problems:
//   - Host key changes on every server restart
//   - Clients see "host key changed" warnings
//   - Users must manually accept new key on each restart
//   - Breaks automation and scripting
//   - No way to backup/restore server identity
//
// Use Instead:
//   loadOrGenerateHostKey(keyPath string) - Generates persistent key
//
// Why This Still Exists:
// Kept for backward compatibility with old code that might reference it.
// Will be removed in a future version.
//
// Migration Path:
// If you're calling this function, change to:
//   signer, err := loadOrGenerateHostKey("data/ssh_host_key")
//
// Returns:
//   - ssh.Signer: Temporary signing interface (NOT persisted)
//   - error: Cryptographic generation failure
func generateHostKey() (ssh.Signer, error) {
	log.Warn("Using deprecated generateHostKey() - use loadOrGenerateHostKey() instead")

	_, privateKey, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate key: %w", err)
	}

	signer, err := ssh.NewSignerFromKey(privateKey)
	if err != nil {
		return nil, fmt.Errorf("failed to create signer: %w", err)
	}

	return signer, nil
}
